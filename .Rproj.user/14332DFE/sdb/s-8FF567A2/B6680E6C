{
    "collab_server" : "",
    "contents" : "\n#' Summary of Covariates\n#'\n#' This function allows you to explore the discriminatory power of covariates\n#' against a binary target, and summarizes the number of NA and 0 in each of\n#' the covariates.\n#'\n#' If the Type is \"Binary\", it returns a data.table containing the names of\n#' covariates, number of NA, number of 0, and Area Under the Curve (AUC).\n#'\n#' If the Type is \"Continuous\", it returns a data.table containing the names of\n#' covariates, number of NA, number of 0, Adjusted R-squared, and p-value.\n#'\n#' @param Target A string of the name of binary target to be predicted.\n#' @param Data A data.frame containing both the target and covariates.\n#' @param Skip A vector of strings containing the names of columns to be\n#' skipped, such as ID.\n#' @param Type The type of dependent variables, either \"Binary\" or\n#' \"Continuous\". Default is \"Binary\".\n#' @export\n#' @examples VariableSummary(Target = \"am\", Data = mtcars, Skip = c(\"vs\", \"carb\"), Type = \"Binary\")\n\nCovariateSummary <- function(Target, Data, Skip = NULL, Type = \"Binary\"){\n\n  DF <- data.frame(Data)\n\n  ColNames <- names(DF)\n  SkipPosition <- which(ColNames %in% Skip)\n  TargetPosition <- which(ColNames == Target)\n  CovarPosition <- c(1:length(ColNames))\n  CovarPosition <- CovarPosition[! CovarPosition %in% c(SkipPosition,\n                                                        TargetPosition)]\n  if(Type == \"Binary\"){\n    AUC <- c()\n    `Count of NA` <- c()\n    `Count of 0` <- c()\n    Type <- c()\n\n    for(i in 1:length(CovarPosition)){\n      Type[i] <- class(DF[, CovarPosition[i]])\n      AUC[i] <- round(AUROC(DF[, TargetPosition],\n                            DF[, CovarPosition[i]]), 4)\n      `Count of NA`[i] <- sum(is.na(DF[, CovarPosition[i]]))\n      `Count of 0` [i] <- sum(DF[, CovarPosition[i]] == 0, na.rm = T)\n    }\n\n    Covariate <- names(DF)[CovarPosition]\n\n    Results <- data.table(cbind(Covariate, Type, `Count of NA`, `Count of 0`,\n                                AUC))\n  } else if(Type == \"Continuous\"){\n    Type <- c()\n    `Count of NA` <- c()\n    `Count of 0` <- c()\n    Formula <- c()\n    `Adj. R squared` <- c()\n    `p-value` <- c()\n\n    for(i in 1:length(CovarPosition)){\n      Type[i] <- class(DF[, CovarPosition[i]])\n      `Count of NA`[i] <- sum(is.na(DF[, CovarPosition[i]]))\n      `Count of 0` [i] <- sum(Data[, CovarPosition[i]] == 0, na.rm = T)\n      `Adj. R squared`[i] <- round(ARS(DF[, TargetPosition],\n                                       DF[, CovarPosition[i]]), 4)\n      `p-value`[i] <- round(Significance(DF[, TargetPosition],\n                                         DF[, CovarPosition[i]]), 4)\n    }\n\n    Covariate <- names(DF)[CovarPosition]\n\n    Results <- data.table(cbind(Covariate, Type, `Count of NA`, `Count of 0`,\n                                `Adj. R squared`, `p-value`))\n  } else{\n    stop(\"Type has to be specified as either Binary or Continuous.\")\n  }\n  return(Results)\n}\n\n#' Cross Table of Categorical Covariates\n#'\n#' This function generates a data.table tabulating the different levels of a categorical\n#' independent variable and the corresponding probabilities of the binary dependent\n#' variable taking the value of 1.\n#'\n#' @param Target The name of binary target to be predicted.\n#' @param Covariate The name of the covariate.\n#' @param Data A data.table containing both the target and covariate.\n#' @export\n#' @examples gearTable <- CategoricalTable(Target = \"am\", Covariate = \"gear\", Data = mtcars)\n\nCategoricalTable <- function(Target, Covariate, Data){\n  DT1 <- data.table(Data)\n  ColNames <- names(Data)\n  TargetPosition <- which(ColNames == Target)\n  CovariatePosition <- which(ColNames == Covariate)\n\n  DT1 <- DT1[, c(TargetPosition, CovariatePosition), with = F]\n  setnames(DT1, Target, \"Target\")\n  setnames(DT1, Covariate, \"Covariate\")\n\n  DT1 <- DT1[, list(Event = sum(Target),\n                    `Non Event` = sum(Target == 0)),\n             by = Covariate]\n  DT1[, Counts := Event + `Non Event`]\n  DT1[, Probability := round(Event/ Counts, 4)]\n  DT1[, Logit := log ((Event/sum(Event)) / (`Non Event`/sum(`Non Event`)))]\n\n  NA.Position <- which(is.na(DT1[, 1]))\n  Order <- order(DT1[, 1])\n  Order <- c(NA.Position, Order[!Order %in% NA.Position])\n  DT1 <- DT1[Order, ]\n  setnames(DT1, \"Covariate\", Covariate)\n  return(DT1)\n}\n\n#' Cross Table of Numerical Covariates\n#'\n#' This function generates a data.table tabulating the different ranges of a continuous\n#' covariate and the corresponding probabilities of the binary dependent\n#' variable taking the value of 1.\n#'\n#' @param Target The name of binary target to be predicted.\n#' @param Covariate The name of the covariate.\n#' @param Data A data.table containing both the target and covariate.\n#' @export\n#' @examples mpgTable <- NumericalTable(Target = \"am\", Covariate = \"mpg\", Data = mtcars)\n\n\nNumericalTable <- function(Target, Covariate, Data, NumberOfBins = 5,\n                           CustomBins = F, CustomIntervals = NULL){\n  DT1 <- data.table(Data)\n  ColNames <- names(Data)\n  TargetPosition <- which(ColNames == Target)\n  CovariatePosition <- which(ColNames == Covariate)\n  DT1 <- DT1[, c(TargetPosition, CovariatePosition), with = F]\n  setnames(DT1, Target, \"Target\")\n  setnames(DT1, Covariate, \"Covariate\")\n\n  if(CustomBins == F){\n    Breaks <- quantile(DT1[, \"Covariate\"], probs = seq(0, 1, 1/ NumberOfBins),\n                       na.rm = T)\n  } else {\n    Breaks <- CustomIntervals\n  }\n\n  DT1[, Categories := cut(Covariate, breaks = Breaks, include.lowest = T)]\n\n  DT1 <- DT1[, list(Event = sum(Target),\n                    `Non Event` = sum(Target == 0)),\n             by = Categories]\n  DT1[, Counts := Event + `Non Event`]\n  DT1[, Probability := round(Event/ Counts, 4)]\n  DT1[, Logit := log ((Event/sum(Event)) / (`Non Event`/sum(`Non Event`)))]\n\n  LowerBounds <- gsub(\"^.*\\\\(\", \"\", as.character(DT1[, Categories]))\n  LowerBounds <- gsub(\"^.*\\\\[\", \"\", LowerBounds)\n  LowerBounds <- gsub(\",.*$\", \"\", LowerBounds)\n  LowerBounds <- as.numeric(LowerBounds)\n\n  NAPosition <- which(is.na(LowerBounds))\n  Order <- order(LowerBounds)\n  Order <- c(NAPosition, Order[!Order %in% NAPosition])\n  DT1 <- DT1[Order, ]\n  setnames(DT1, \"Categories\", Covariate)\n  return(DT1)\n}\n\n#' Generate Logit\n#'\n#' This function generates a new column containing the conditional logit\n#' corresponding to a covariate.\n#'\n#' @param Data A data.frame or data.table for which a new column will be\n#' generated in.\n#' @param CrossTable A cross table with the different levels of the covariate.\n#' @param Covariate The name of the covariate.\n#' @export\n#' @examples\n#' Discretize a continuous covariate\n#' mtcars[, mpgCat := cut(mpg, breaks = c(10, 17, 21, 35), include.lowest = T)]\n#'\n#' Generate the conditional logit\n#' mtcars <- GenerateLogit(mtcars, mpgTable, \"mpgCat\")\n\nGenerateLogit <- function(Data, CrossTable, Covariate){\n  DT1 <- copy(CrossTable)\n  setnames(DT1, names(DT1)[1], Covariate)\n  NewName <- paste0(Covariate, \"Logit\")\n  setnames(DT1, \"Logit\", NewName)\n  DTJoined <- merge(Data, DT1[, c(Covariate, NewName), with = F],\n                    by = Covariate)\n  return(DTJoined)\n}\n\n#' Weights of Covariates\n#'\n#' This function takes the regression object and calculates the relative\n#' importance of different covariates.\n#' The relative importance is only valid when the covariates are standardized.\n#'\n#' @param Model A \"lm\" or \"glm\" object.\n#' @param Rounding Desired rounding, default is up to 2 decimal places.\n#' @param Exact If Exact = TRUE, the function will return weights with the sum of exactly\n#' 100. Default is set to FALSE, to reduce time required for computation.\n#' @param Intercept Does the regression object have an intercept term? Default is set to\n#' TRUE.\n#' @export\n#' @examples CovariateWeights(RegressionModel, Rounding = 1, Exact = TRUE)\n\nCovariateWeights <- function(Model, Rounding = 0.01, Exact = FALSE, Intercept = TRUE){\n  if (Intercept == TRUE) {\n    ModelCoefficients <- Model$coefficients[-1]\n  } else {\n    ModelCoefficients <- Model$coefficients\n  }\n  Weights <- (ModelCoefficients / sum(ModelCoefficients))*100\n  RoundWeights <- Rounding*round(Weights/ Rounding)\n  if(Exact == T){\n    Difference <- RoundWeights - Weights\n    if(sum(Difference) != 0){\n      Adjustments <- sum(Difference)/ Rounding\n      RoundWeights[order(Difference, decreasing = T)][1: Adjustments] <-\n        RoundWeights[order(Difference, decreasing = T)][1: Adjustments] - Rounding\n    }\n  }\n  return(RoundWeights)\n}\n\n#' Area Under the ROC Curve\n#'\n#' This function computes the AUC, and returns the numeric value of it.\n#'\n#' @param Target A vector with values of 0/1 to be predicted.\n#' @param Prediction A vector of prediction or covariate used to predict the target.\n#' @export\n#' @examples AUROC(mtcars$am, mtcars$mpg)\n\nAUROC <- function(Target, Prediction){\n  if(length(Target) != length(Prediction)){\n    stop(\"Target and Prediction must be of the same length.\")\n  } else{\n  if(is.numeric(Prediction) == T){\n    Order <- order(Prediction)\n    Order <- Order[!Order %in% which(is.na(Prediction))]\n    Prediction <- Prediction[Order]\n    Target <- Target[Order]\n\n    FP <- cumsum(!Target)/sum(!Target)\n    TP <- cumsum(Target)/sum(Target)\n\n    Repeated <- c(Prediction[-1] == Prediction[-length(Prediction)], FALSE)\n\n    FP <- c(0, FP[!Repeated], 1)\n    TP <- c(0, TP[!Repeated], 1)\n\n    } else if(is.factor(Prediction) == T | is.character(Prediction) == T){\n\n    DT1 <- data.table(Y = Target, X = Prediction)\n    DT1 <- DT1[, list(Event = sum(Y),\n                      `Non Event` = sum(!Y)),\n               by = X]\n    DT1[, Probability := Event / (Event + `Non Event`)]\n    DT1 <- DT1[order(Probability), ]\n\n    FP <- c(0, cumsum(DT1[, `Non Event`])/ sum(DT1[, `Non Event`]), 1)\n    TP <- c(0, cumsum(DT1[, Event])/ sum(DT1[, Event]), 1)\n\n    } else{\n      \"The class of Prediction should be eiher numeric or factor.\"\n  }\n    N <- length(FP)\n    TpAvg <- (TP[-1] + TP[-N])/ 2\n    FpDif <- FP[-1] - FP[-N]\n\n    Area <- sum(TpAvg * FpDif)\n    Results <- 0.5 + abs(Area - 0.5)\n    return(Results)\n  }\n}\n\n#' Plot ROC Curve\n#'\n#' This function plots the ROC curve.\n#'\n#' @param Target A vector with values of 0/1 to be predicted.\n#' @param Prediction A vector of prediction or covariate used to predict the target.\n#' @param ... Other parameters for plot().\n#' @export\n#' @examples PlotROC(mtcars$am, mtcars$mpg)\n\nPlotROC <- function(Target, Prediction, ...){\n  if(length(Target) != length(Prediction)){\n    stop(\"Target and Prediction must be of the same length.\")\n  } else{\n  if(is.numeric(Prediction) == T){\n    Order <- order(Prediction, decreasing = T)\n    Order <- Order[!Order %in% which(is.na(Prediction))]\n    Prediction <- Prediction[Order]\n    Target <- Target[Order]\n\n    FP <- cumsum(!Target)/sum(!Target)\n    TP <- cumsum(Target)/sum(Target)\n\n    Repeated <- c(Prediction[-1] == Prediction[-length(Prediction)], FALSE)\n\n    FP <- c(0, FP[!Repeated], 1)\n    TP <- c(0, TP[!Repeated], 1)\n\n  } else if(is.factor(Prediction) == T | is.character(Prediction) == T){\n\n    DT1 <- data.table(Y = Target, X = Prediction)\n    DT1 <- DT1[, list(Event = sum(Y),\n                      `Non Event` = sum(!Y)),\n               by = X]\n    DT1[, Probability := Event / (Event + `Non Event`)]\n    DT1 <- DT1[order(Probability), ]\n\n    FP <- c(0, cumsum(DT1[, `Non Event`])/ sum(DT1[, `Non Event`]), 1)\n    TP <- c(0, cumsum(DT1[, Event])/ sum(DT1[, Event]), 1)\n\n  } else{\n    \"The class of Prediction should be eiher numeric or factor.\"\n  }\n    N <- length(FP)\n    TpAvg <- (TP[-1] + TP[-N])/ 2\n    FpDif <- FP[-1] - FP[-N]\n    Area <- sum(TpAvg * FpDif)\n\n    if(Area < 0.5){\n      TP <- 1 - TP\n      FP <- 1 - FP\n    }\n\n  plot(FP, TP, xlab = \"False Positive Rate\", ylab = \"True Positive Rate\",\n       type = \"l\", pch = 16, ... = ...)\n  }\n}\n\n#' Univariate Adjusted R Squared\n#'\n#' This function computes the Adjusted R Squared equivalent to that obtained\n#' from a linear regression.\n#'\n#' @param Target A vector of the dependent variable.\n#' @param Prediction A vector of the predictions.\n#' @export\n#' @examples ARS(mtcars$mpg, mtcars$cyl)\n\nARS <- function(Target, Prediction){\n  if(length(Target) != length(Prediction)){\n    stop(\"Target and Prediction must be of the same length.\")\n  } else{\n  NA.Index <- unique(c(which(is.na(Target)), which(is.na(Prediction))))\n  Target <- Target[!1:length(Target) %in% NA.Index]\n  Prediction <- Prediction[!1:length(Prediction) %in% NA.Index]\n\n  if(is.numeric(Prediction) == T){\n    RS <- cor(Target, Prediction)^2\n    K <- 1\n  } else if(is.factor(Prediction) == T | is.character(Prediction) == T){\n    DT1 <- data.table(Y = Target, X = Prediction)\n    DT1[, AvgTarget := mean(Y), by = X]\n    RS <- cor(DT1[, Y], DT1[, AvgTarget])^2\n    K <- length(unique(Prediction)) - 1\n  }\n  ARS <- 1 - (1- RS) * (length(Prediction) - 1) / (length(Prediction) - K - 1)\n  return(ARS)\n  }\n}\n\n#' Univariate Statistical Significance\n#'\n#' This function computes the Statistical Significance (p-value) equivalent to\n#' that obtained from a linear regression.\n#'\n#' @param Target A vector of the dependent variable.\n#' @param Prediction A vector of the predictions.\n#' @export\n#' @examples Significance(mtcars$mpg, mtcars$cyl)\n\nSignificance <- function(Target, Prediction){\n  if(length(Target) != length(Prediction)){\n    stop(\"Target and Prediction must be of the same length.\")\n  } else{\n  NA.Index <- unique(c(which(is.na(Target)), which(is.na(Prediction))))\n  Target <- Target[!1:length(Target) %in% NA.Index]\n  Prediction <- Prediction[!1:length(Prediction) %in% NA.Index]\n\n  if(is.numeric(Prediction) == T){\n    RS <- cor(Target, Prediction)^2\n    K <- 1\n  } else if(is.factor(Prediction) == T | is.character(Prediction) == T){\n    DT1 <- data.table(Y = Target, X = Prediction)\n    DT1[, AvgTarget := mean(Y), by = X]\n    RS <- cor(DT1[, Y], DT1[, AvgTarget])^2\n    K <- length(unique(Prediction)) - 1\n  }\n  df1 <- K\n  df2 <- length(Prediction) - K - 1\n  FStat <- (RS/ (1-RS))/ (df1/ df2)\n  Significance <- 1 - pf(FStat, df1, df2)\n  return(Significance)\n  }\n}\n\n#' Logarithmic Loss\n#'\n#' This function computes the logarithmic loss for binary predictions.\n#'\n#' @param Target A vector of the binary dependent variable.\n#' @param Prediction A vector of the predictions.\n#' @export\n#' @examples LogLoss(Data[, Y], Model$fitted.values)\n\nLogLoss <- function(Target, Prediction){\n  -sum(Target * log(Prediction + 1e-99) +\n         (1 - Target) * log(1 - Prediction - 1e-99))/\n    length(Target)\n}\n",
    "created" : 1514448621123.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1902378845",
    "id" : "B6680E6C",
    "lastKnownWriteTime" : 1514448682,
    "last_content_update" : 1514448682056,
    "path" : "~/R Package Development/LiteXploreR/R/LiteXploreR_functions.R",
    "project_path" : "R/LiteXploreR_functions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}